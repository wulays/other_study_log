#### 简介

**Docker 是什么**

是一种创建和使用 Linux 容器的容器化技术，而容器就是一种打包技术，就像去露营一样，传统方式你得搭帐篷，睡袋，路子什么的，都得一个一个手动搭建好。而容器化就像房车一样，里面的东西都准备齐全了，到了目的地不需要再去手动安装，只需要打开房车门就可以是哦那个了，在每个地方的运行环境都是一样的。这样就确保了任何环境下都能以相同的方式运行起来，不用担心常说的 “我的电脑上没有问题，到你那就不行了”

毕竟基于 Linux 容器实现的，Linux 好说直接共享同样的内核就可以了，在 Windows 和 Mac 上就是使用虚拟机来实现了，内置一个轻量的虚拟机来运行 Linux 内核，另外在Win10 之后，还可以使用 WSL 来实现无需额外虚拟机，性能和体验都有提升

**什么是容器**

就像一个一个的集装箱，根据不同的货物可以改变不同的内部环境，如需要装活鱼就可以在箱子里注水，再放入鱼，如果是树木，就可能需要土壤。每个集装箱都是不同的，也都可以装不同类型的东西或者说软件，环境也是分离开的。无论箱子在哪里打开就能用到里面的东西。

就像一个盒子里面可以装各种软件，每一个的软件环境都是提前配置好了的，需要用到的时候直接运行就可以了。而且每一个箱子都是分离开来的也不会有冲突，这就很简单方便了

**是什么镜像**

什么是镜像就是对布置好的集装箱，拍了一个照片，下一次还想要一个这种集装箱就照着这个去创建一个一模一样的集装箱，就像一个模板一样，可以再次创建一个一模一样的集装箱实例，也可以很方便的分享给别人。


#### 运行一个容器

在 docker 安装完成之后可以使用

```shell
docker run hello-world

# 输出 Hello from Docker! 巴拉巴拉
```

这个命令会从 Docker Hub 下载一个测试镜像并在一个新容器中运行它。

> Docker Hub 就是一个仓库，上面是存储 Docker 镜像和分享的地方，类似于 GitHub

这是一个很常用的命令，`docker run 镜像名称` 从本地仓库或者远程仓库获取这个镜像，再根据这个镜像去创建一个新的容器。

如需要在 docker  上运行一个 `nginx`

```bash
docker run nginx
```

这个时候就会发现，运行时运行了，但是吧终端被它给我占用了，毕竟是一个服务，而不是执行完命令就结束了，z这个终端关了服务也就停了。这个时候就可以考虑在运行的时候加上一些参数来改变这种情况了，如不想让他占用我们的终端，让他在后台运行，可以使用参数 `-d`  表示后台模式

```bash
docker run -d nginx
```

参数在镜像名称前面，这个时候会返回一串容器的`id`值 可以根据这个 `id` 来管理这个容器，运行时运行了，可是要怎么才能看到运行的这些容器呢

```bash
docker ps
```

就可以查看到运行的容器列表了，如果要查看包括未运行的容器可以加上参数 `-a`

不过这也太长了吧，根本记不，这个时候还可以加一些参数在运行的时候指定一个名称什么的 `--name`

```bash
docker run -d --name nginx-demo nginx
```

这样下次就知道这个容器时哪一个了

既然启动的是一个服务，那自然是需要去访问这个服务的，但是现在并不能访问这个服务，因为它是在集装箱里面提供服务，我们却在集装箱外面，这个时候就需要这个集装箱开一个窗口了，来对外进行服务，使用`-p` 参数对端口进行映射，也就在外面开启一个对外服务的窗口，然后通过这个窗口就可以来到集装箱里面的窗口来使用这个服务

```bash
docker run -d -p 8888:80 --name nginx-demo nginx
```

这个时候再去使用 `localhost:8888` 就可以访问到容器里面的 `nginx` 提供的服务了

如果不想让他提供服务了可以使用

```bash
docker stop nginx-demo
```

这样就可以停止一个正在运行的服务了，不过虽然停止了，但是这个容器依然还是在的，可以再次重启它

```bash
docker start nginx-demo
```

这样就能再次启动这个服务了，也可以在运行的时候直接重启它

```bash
docker restart nginx-demo
```

当想删除一个容器的时候也可以使用 

```bash
docker rm nginx-demo
```

这样就可以去删除一个容器了，不过在删除的时候需要停止这个容器

####  定制一个镜像

有时候有需要也可以自己去定义集装箱里的东西，这个时候就可以去创建一个镜像了，主要通过两种方式来创建镜像

1. 通过 `docker commit` 的方式
	-  这种方式适合于临时的调试，比如基于当前的容器新增了一些软件或者改了一些东西，就可以基于当前的这个容器来创建一个新镜像
2. 通过 `Dockerfile` 的方式
	- 包含用户定义的一系列指令和参数的文本文件，可以纳入版本控制系统，也容易复现管理，每条指令都是构建镜像的一个层，推荐方式


首先就先创建 `Dockerfile` 文件，写上如上内容

```text
FROM nginx
RUN echo '<h1>Hello Dockerfile</h1>' > /user/share/nginx/html/index.html
```

这个 Dockerfile 很简单，一共就两行，涉及到了两条指令，`FROM` 和 `RUN`

毕竟是定制，所以还是需要一个基础的镜像的，这里就指定了一个 `nginx` 镜像为基础镜像，使用 `FROM` 来指定**基础镜像**

除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 `scratch`。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。

```text
FROM scratch
```

如果你以 `scratch` 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。

不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 `FROM scratch` 会让镜像体积更加小巧。


`RUN` 指令是用来执行命令的，有两种格式

- shell 格式
	- 就像在终端中输入命令一样，刚才写的就是这种格式
- exec 格式
	- 这种格式更像函数中调用的格式
		- RUN ["命令", "参数", "参数"]

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。


如果要执行多个命令怎么办，写多个 `RUN` 吗

```text
FROM  debian:strecth

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
#...
```

这样就会创建很多层，一行命令执行完后就会 `commit` 这一层的修改，构成新的镜像，这样其实是没有意义的，没必要建立多层，因为目标就是一个，所以可以使用 `&&` 将所需的命令串联起来

```text
FROM debian:strecth

RUN set -x; buildDeps='gcc libc6-dev make wget' \
    && apt-get update \
    && ...
```

这样做就只会去提交一层镜像，Dockerfile 支持 Shell 类的行尾添加 `\` 的命令换行方式，以及行首 `#` 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。

接下来我们创建一个 `Dockfile` 来创建一个属于自己的镜像吧

```text
FROM nginx
```

就只使用一个基础镜像，别的都先不用，这里使用了 `docker build` 命令进行镜像构建。其格式为：

```bash
docker build [选项] <上下文路径/URL/ >

# 这里我们写为
docker build .
```

等待一会之后就会看到构建完成的镜像 `ID` 了，我们可以使用

```bash
docker image ls
```

来查看拥有的镜像列表，这个时候可以看到一个 `none` 的镜像，就是我们刚创建的，因为没有给名字所以叫 `none`

```bash
docker rmi 镜像ID
```

可以通过这个命令来删除不用的镜像，毕竟没有名字，所以这里用ID来删除

那什么又是镜像的上下文呢，这里用的 `.` 表示当前目录，将这个路径下的内容全部打包给 `Docker` 守护进程，用来在构建镜像的过程中使用，也尽量不要将不必要的文件和目录包括在内，不然东西多了也会导致镜像构建缓慢，还会增加镜像大小

当然如果不需要上下文中的一些文件或者目录也可以使用 `.dockerignore` 文件来忽略掉这些不需要的文件

上下文有什么用呢，例如这里有一个 `COPY` 命令

```text
COPY ./package.json /app/
```

这个可不是负责当前目录，而是上下文目录中去复制 `./package.json` 到指定位置

这个上下文路径还可以使用 `URL` 地址

```bash
docker build https://github.com/docker-library/hello-world.git#master:amd64/hello-world
```

这行命令指定了构建所需的 Git repo，并且指定分支为 `master`，构建目录为 `/amd64/hello-world/`，然后 Docker 就会自己去 `git clone` 这个项目、切换到指定分支、并进入到指定目录后开始构建。

```bash
docker build http://server/context.tar.gz
```

如果所给出的 URL 不是个 Git repo，而是个 `tar` 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建


#### Dockerfile 指令

- COPY 复制文件

`COPY` 指令将从构建上下文目录中的文件/目录复制到新的一层的镜像内的位置

```bash
COPY package.json /usr/app/
```

源路径可以是多个或者通配符，而目标路径可以是容器内的绝对路径，也可以是相对于工作目录的相对路径，工作目录可以用 `WORKDIR` 来指定。如果目标路径不存在会在复制文件之前西安创建没有的目录

- ADD 更高级的复制文件

本质上和 `COPY` 一样，不过 `ADD` 的源路径可以是一个 `URL`，Docker 会去尝试下载这个连接的文件然后放到目标路径去，不过这种方式可以使用 `RUN` 命令来替代，不过如果是 `tar`或者`gzip`、`bzip2`、`xz` 的情况下 `ADD` 命令会自动解压在放到目标目录去，适合的使用场景也就是自动复制解压的情况

- CMD 容器启动命令

提供了默认的命令及其参数,跟在镜像名后面的是 `command`，运行时会替换 `CMD` 的默认值

和 `RUN` 一样也是两种写法，`shell`和`exec`格式

```bash
CMD ["命令", "参数1", "参数2"]
```

`CMD` 指令就是用于指定默认的容器主进程的启动命令的

在指令格式上，一般推荐使用 `exec` 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 `"`，而不要使用单引号

但是也要注意，提到 `CMD` 就不得不提容器中应用在前台执行和后台执行的问题，Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 `systemd` 去启动后台服务，容器内没有后台服务的概念

```bash
CMD service nginx start
```

然后发现容器执行后就立即退出了。甚至在容器内去使用 `systemctl` 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西

而使用 `service nginx start` 命令，则是希望 init 系统以后台守护进程的形式启动 nginx 服务。而刚才说了 `CMD service nginx start` 会被理解为 `CMD [ "sh", "-c", "service nginx start"]`，因此主进程实际上是 `sh`。那么当 `service nginx start` 命令结束后，`sh` 也就结束了，`sh` 作为主进程退出了，自然就会令容器退出。

正确的做法是直接执行 `nginx` 可执行文件，并且要求以前台形式运行。比如

```bash
CMD ["nginx", "-g", "daemon off;"]
```

`-g` 是 Nginx 命令的一个参数，表示设置全局指令。

 `"daemon off;"` 是传给 `-g` 的参数值，它告诉 Nginx 在前台运行，而不是以守护进程（后台服务）的方式运行。这一点对 Docker 容器来说非常重要，因为容器会持续运行直到其启动的主进程结束。如果 Nginx 以守护进程形式运行，那么命令将会立即结束，导致容器退出。

- ENTRYPOINT 入口点

和 `CMD` 一样指定容器启动程序及参数，不过相对复杂一些，那为什么还需要这个呢，这个主要是可以定义 容器运行时的命令，将 Docker 档次一个命令行程序来用

```text
FROM ubuntu:18.04
RUN apt-get update \
    && apt-get install -y curl \
    && rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]
```

那么如果我们希望加入 `-i` 这参数

```bash
docker run xxx -i
```

因为当存在 `ENTRYPOINT` 后，`CMD` 的内容将会作为参数传给 `ENTRYPOINT`，而这里 `-i` 就是新的 `CMD`，因此会作为参数传给 `curl`，从而达到了我们预期的效果

当指定了 `ENTRYPOINT` 后，`CMD` 的含义就发生了改变，不再是直接的运行其命令，而是将 `CMD` 的内容作为参数传给 `ENTRYPOINT` 指令

```bash
<ENTRYPOINT> "<CMD>"
```

- ENV 设置环境变量

格式有两种 `ENV KEY VALUE` 或者 `ENV KEY=VALUE`

```text
ENV A=1 B=2 \
	C="123"
```

例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法

如果要在下方使用变量就需要加上 `$` 符号

```bash
$A
```

- ARG 构建参数

和 `ENV` 的效果一样，都是设置环境变量，不过去别的时，在容器运行时，是不会存在这些环境变量的

```text
ARG A=10

FROM xxx

RUN ...
```

ARG 指令如果在 `FROM` 之前那么只能用于 `FROM` 指令中

```bash
# 只在 FROM 中生效
ARG DOCKER_USERNAME=library

FROM ${DOCKER_USERNAME}/alpine

# 要想在 FROM 之后使用，必须再次指定
ARG DOCKER_USERNAME=library

RUN set -x ; echo ${DOCKER_USERNAME}
```

 - VOLUME 定义匿名卷

`VOLUME 路径

创建一个挂载点，在容器和宿主机的文件系统进行交互共享数据

```text
VOLUME /data
```

这里的 `/data` 目录就会在容器运行时自动挂载为匿名卷

- EXPOSE 暴露端口

`EXPOSE 端口1`

声明容器运行时提供服务的端口，只是一个声明，容器运行时并不会因为这个声明就去开启这个端口服务，主要是帮助镜像使用者理解，方便配置映射，或则使用 `docker run -P` 时会自动映射端口

- WORKDIR 指定工作目录

`WORKDIR 工作目录`

用来指定工作目录或者称为当前目录，如果目录不存在则会自动创建这个目录

- USER 指定当前用户

和 `WORKDIR` 类似，都是改变环境状态，`WORKDIR` 改变工作目录， `USER` 则时改变之后层的执行 `RUN` `CMD` `ENTRYPOINT` 这类命令的身份，也就是切换指定用户

- HEALTHCHECK 健康检查

告诉 Docker 如何进行判断容器的状态是否正常的

- SHELL 指令
就是指定运行 `RUN` 这些的 shell Linux 中默认为  `["/bin/sh", "-c"]`